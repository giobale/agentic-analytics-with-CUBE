# ABOUTME: CUBE API client for executing queries generated by LLM
# ABOUTME: Based on existing CubeAPIClient with enhanced error handling and response formatting

import requests
import json
import pandas as pd
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
import os
import jwt


class CubeClient:
    """
    CUBE API client for executing queries generated by the LLM.
    Handles authentication, query execution, and result formatting.
    """

    def __init__(self,
                 base_url: str = "http://localhost:4000",
                 api_secret: str = "baubeach",
                 results_dir: str = "results"):
        """
        Initialize CUBE client.

        Args:
            base_url: CUBE API base URL
            api_secret: CUBE API secret
            results_dir: Directory to save CSV results
        """
        self.base_url = base_url
        self.api_secret = api_secret
        self.jwt_token = None
        self.results_dir = results_dir
        self.session = requests.Session()
        self.session.headers.update({'Content-Type': 'application/json'})

        # Create results directory if it doesn't exist
        os.makedirs(self.results_dir, exist_ok=True)

    def initialize(self) -> Dict[str, Any]:
        """
        Initialize connection to CUBE API.

        Returns:
            Initialization result with status and metadata
        """
        try:
            # Get JWT token
            token_result = self._get_jwt_token()
            if not token_result:
                return {
                    "success": False,
                    "error": "Failed to retrieve JWT token",
                    "details": "Could not authenticate with CUBE API"
                }

            # Test connection
            connection_result = self._test_connection()
            if not connection_result:
                return {
                    "success": False,
                    "error": "Failed to connect to CUBE API",
                    "details": f"API not accessible at {self.base_url}"
                }

            # Get metadata
            metadata = self._get_meta()

            return {
                "success": True,
                "metadata": metadata,
                "available_cubes": self._extract_cube_names(metadata),
                "base_url": self.base_url,
                "timestamp": datetime.now().isoformat()
            }

        except Exception as e:
            return {
                "success": False,
                "error": f"Initialization failed: {str(e)}",
                "details": "Unexpected error during CUBE client initialization"
            }

    def execute_query(self, cube_query: Dict[str, Any], user_query: Optional[str] = None) -> Dict[str, Any]:
        """
        Execute a CUBE query generated by the LLM.

        Args:
            cube_query: CUBE query dictionary
            user_query: Optional user's natural language query for better file naming

        Returns:
            Query execution result with data and metadata
        """
        try:
            # Validate query structure
            validation_result = self._validate_query(cube_query)
            if not validation_result["valid"]:
                return {
                    "success": False,
                    "error": "Invalid query structure",
                    "details": validation_result["errors"],
                    "original_query": cube_query
                }

            # Execute query
            response = self.session.post(
                f"{self.base_url}/cubejs-api/v1/load",
                json={"query": cube_query}
            )
            response.raise_for_status()
            result = response.json()

            if 'data' in result:
                data = result['data']

                # Save to CSV
                csv_filename = self._save_to_csv(data, cube_query, user_query)

                return {
                    "success": True,
                    "data": data,
                    "row_count": len(data),
                    "csv_filename": csv_filename,
                    "csv_path": os.path.join(self.results_dir, csv_filename),
                    "query_metadata": {
                        "measures": cube_query.get("measures", []),
                        "dimensions": cube_query.get("dimensions", []),
                        "filters": cube_query.get("filters", []),
                        "execution_time": datetime.now().isoformat()
                    }
                }
            else:
                return {
                    "success": False,
                    "error": "No data returned from query",
                    "details": result,
                    "original_query": cube_query
                }

        except requests.exceptions.RequestException as e:
            return {
                "success": False,
                "error": f"API request failed: {str(e)}",
                "details": "Failed to communicate with CUBE API",
                "original_query": cube_query
            }
        except Exception as e:
            return {
                "success": False,
                "error": f"Query execution failed: {str(e)}",
                "details": "Unexpected error during query execution",
                "original_query": cube_query
            }

    def get_available_cubes(self) -> List[str]:
        """
        Get list of available cubes.

        Returns:
            List of cube names
        """
        try:
            metadata = self._get_meta()
            return self._extract_cube_names(metadata)
        except Exception:
            return []

    def validate_cube_query(self, cube_query: Dict[str, Any]) -> Dict[str, Any]:
        """
        Validate CUBE query structure without executing it.

        Args:
            cube_query: CUBE query to validate

        Returns:
            Validation result
        """
        return self._validate_query(cube_query)

    def _get_jwt_token(self) -> bool:
        """Generate JWT token for CUBE API authentication."""
        try:
            # Generate JWT token with empty payload as recommended by CUBE.js docs
            # for development environments
            payload = {
                'iat': int(datetime.now().timestamp()),
                'exp': int((datetime.now() + timedelta(days=30)).timestamp())
            }

            self.jwt_token = jwt.encode(payload, self.api_secret, algorithm='HS256')

            # Update session headers with JWT token
            self.session.headers.update({
                'Authorization': f'Bearer {self.jwt_token}'
            })
            return True

        except Exception as e:
            print(f"Error generating JWT token: {str(e)}")
            return False

    def _test_connection(self) -> bool:
        """Test basic connectivity to CUBE API."""
        try:
            response = self.session.get(f"{self.base_url}/readyz")
            response.raise_for_status()
            return True
        except requests.exceptions.RequestException:
            return False

    def _get_meta(self) -> Optional[Dict[str, Any]]:
        """Get metadata about available cubes."""
        try:
            response = self.session.get(f"{self.base_url}/cubejs-api/v1/meta")
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException:
            return None

    def _extract_cube_names(self, metadata: Optional[Dict[str, Any]]) -> List[str]:
        """Extract cube names from metadata."""
        if not metadata or 'cubes' not in metadata:
            return []
        return [cube['name'] for cube in metadata['cubes']]

    def _validate_query(self, cube_query: Dict[str, Any]) -> Dict[str, Any]:
        """
        Validate CUBE query structure.

        Args:
            cube_query: Query to validate

        Returns:
            Validation result with errors if any
        """
        errors = []

        # Check required fields
        if not isinstance(cube_query, dict):
            errors.append("Query must be a dictionary")
            return {"valid": False, "errors": errors}

        # Must have at least measures or dimensions
        measures = cube_query.get("measures", [])
        dimensions = cube_query.get("dimensions", [])

        if not measures and not dimensions:
            errors.append("Query must have at least one measure or dimension")

        # Validate measures format
        if measures and not isinstance(measures, list):
            errors.append("Measures must be a list")

        # Validate dimensions format
        if dimensions and not isinstance(dimensions, list):
            errors.append("Dimensions must be a list")

        # Validate filters if present
        filters = cube_query.get("filters", [])
        if filters and not isinstance(filters, list):
            errors.append("Filters must be a list")

        # Validate order if present
        order = cube_query.get("order", {})
        if order and not isinstance(order, dict):
            errors.append("Order must be a dictionary")

        # Validate limit if present
        limit = cube_query.get("limit")
        if limit is not None and not isinstance(limit, int):
            errors.append("Limit must be an integer")

        return {
            "valid": len(errors) == 0,
            "errors": errors
        }

    def _save_to_csv(self, data: List[Dict[str, Any]], cube_query: Dict[str, Any], user_query: Optional[str] = None) -> str:
        """
        Save query results to CSV file.

        Args:
            data: Query result data
            cube_query: Original query for filename generation
            user_query: Optional user's natural language query for intelligent naming

        Returns:
            CSV filename
        """
        # Generate filename based on user query and timestamp
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

        # Generate intelligent filename based on user query
        if user_query:
            import re
            # Clean and extract meaningful words from user query
            clean_query = re.sub(r'[^\w\s]', '', user_query.lower())
            # Take first 50 characters and replace spaces with underscores
            query_words = clean_query[:50].replace(' ', '_')
            # Remove any leading/trailing underscores
            query_words = query_words.strip('_')
            filename = f"{query_words}_{timestamp}.csv"
        else:
            # Fallback to generic naming
            measures = cube_query.get("measures", [])
            dimensions = cube_query.get("dimensions", [])

            name_parts = []
            if measures:
                name_parts.append("measures")
            if dimensions:
                name_parts.append("dimensions")

            query_type = "_".join(name_parts) if name_parts else "query"
            filename = f"cube_result_{query_type}_{timestamp}.csv"

        # Convert to DataFrame and save
        if data:
            df = pd.DataFrame(data)

            # Clean column names - remove "ViewName." prefix
            cleaned_columns = []
            for col in df.columns:
                if '.' in col:
                    # Remove everything before the first dot (including the dot)
                    cleaned_col = col.split('.', 1)[1]
                else:
                    cleaned_col = col
                cleaned_columns.append(cleaned_col)

            df.columns = cleaned_columns

            csv_path = os.path.join(self.results_dir, filename)
            df.to_csv(csv_path, index=False)

        return filename

    def get_connection_status(self) -> Dict[str, Any]:
        """
        Get current connection status.

        Returns:
            Connection status information
        """
        return {
            "base_url": self.base_url,
            "has_jwt_token": self.jwt_token is not None,
            "jwt_token_preview": self.jwt_token[:20] + "..." if self.jwt_token else None,
            "api_accessible": self._test_connection(),
            "results_directory": self.results_dir
        }


class CubeClientError(Exception):
    """Custom exception for CUBE client errors."""
    pass