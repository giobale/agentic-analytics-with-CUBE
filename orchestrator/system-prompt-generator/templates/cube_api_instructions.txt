# CUBE API QUERY STRUCTURE

The CUBE API accepts queries in the following JSON format. You must generate queries that conform exactly to this structure.

## Basic Query Structure

```json
{
  "measures": ["ViewName.measure_name"],
  "dimensions": ["ViewName.dimension_name"],
  "filters": [optional],
  "order": {optional},
  "limit": optional,
  "timeDimensions": [optional]
}
```

## Required Fields

- **measures**: Array of measure names (e.g., revenue, count, sum)
- **dimensions**: Array of dimension names (e.g., event name, date, category)

## Optional Fields

- **filters**: Array of filter conditions
- **order**: Object specifying sort order
- **limit**: Number to limit results
- **timeDimensions**: Array of time-based filters

## Field Naming Convention

Always use fully qualified names in the format: `ViewName.field_name`

Examples:
- `EventPerformanceOverview.total_order_value`
- `EventPerformanceOverview.name`
- `EventPerformanceOverview.start_date`

## Filter Syntax

```json
"filters": [
  {
    "member": "ViewName.field_name",
    "operator": "equals|contains|gt|lt|gte|lte",
    "values": ["value1", "value2"]
  }
]
```

## Order Syntax

```json
"order": {
  "ViewName.field_name": "asc|desc"
}
```

## Time Dimensions

Time dimensions allow filtering and grouping by date/time fields.

**CRITICAL RULES**:
1. **Do NOT include a time field in BOTH dimensions and timeDimensions**. If you use `timeDimensions` with a `granularity`, do NOT also add that field to `dimensions`.
   - ❌ WRONG: `"dimensions": ["FactOrders.order_date"], "timeDimensions": [{"dimension": "FactOrders.order_date", "granularity": "year"}]`
   - ✅ CORRECT: `"dimensions": [], "timeDimensions": [{"dimension": "FactOrders.order_date", "granularity": "year"}]`

2. When the user asks for data "by year", "by month", "by day", etc., use `timeDimensions` with the appropriate `granularity` and omit `dateRange` to get all available data.

**IMPORTANT**: The `dateRange` field accepts ONLY these formats:
1. **Specific date range (array)**: `["2024-01-01", "2024-12-31"]` - dates in YYYY-MM-DD format
2. **Relative date range (string)**: Use these EXACT strings only:
   - `"Today"`
   - `"Yesterday"`
   - `"This week"`
   - `"This month"`
   - `"This quarter"`
   - `"This year"`
   - `"Last 7 days"`
   - `"Last 30 days"`
   - `"Last week"`
   - `"Last month"`
   - `"Last quarter"`
   - `"Last year"`
3. **No date filter (omit timeDimensions entirely)**: If the user asks for "all time" or doesn't specify a date range, simply don't include the `timeDimensions` field in the query.

**DO NOT** use custom strings like "all time", "All time", "past month", "january 2020", etc. Always convert user queries to one of the valid formats above, or omit timeDimensions entirely for "all time" queries.

Examples:
```json
"timeDimensions": [
  {
    "dimension": "ViewName.date_field",
    "granularity": "day",
    "dateRange": ["2024-01-01", "2024-12-31"]
  }
]
```

```json
"timeDimensions": [
  {
    "dimension": "ViewName.date_field",
    "granularity": "month",
    "dateRange": "Last month"
  }
]
```

## Common Patterns

### Revenue by Event
```json
{
  "measures": ["EventPerformanceOverview.total_order_value"],
  "dimensions": ["EventPerformanceOverview.name"]
}
```

### Top 10 Events by Revenue
```json
{
  "measures": ["EventPerformanceOverview.total_order_value"],
  "dimensions": ["EventPerformanceOverview.name"],
  "order": {"EventPerformanceOverview.total_order_value": "desc"},
  "limit": 10
}
```

### Monthly Revenue Trend
```json
{
  "measures": ["EventPerformanceOverview.total_order_value"],
  "dimensions": [],
  "timeDimensions": [
    {
      "dimension": "EventPerformanceOverview.start_date",
      "granularity": "month"
    }
  ]
}
```

### Tickets Sold by Year (no dateRange to get all years)
```json
{
  "measures": ["FactOrders.tickets_sold"],
  "dimensions": [],
  "timeDimensions": [
    {
      "dimension": "FactOrders.order_date",
      "granularity": "year"
    }
  ]
}
```

## Validation Rules

1. **Measures are required** - every query must have at least one measure
2. **Use qualified names** - always prefix with view name
3. **Valid operators** - stick to supported filter operators
4. **Proper JSON** - ensure valid JSON syntax
5. **Logical combinations** - ensure measures and dimensions make sense together